# Structural Design Patterns

They deal with how to assemble objects and classes into larger structures

## Why do we need creational patterns?




- Adapter: allows two incompatible interfaces to work together by creating a "middleman" (the adapter).
- Bridge: Decouples abstraction from implementation, so they can evolve independently.
- Composite: lets you compose objects into tree structures and then work with these structures as if they were individual objects.
- Decorator: adding new behaviors to objects dynamically
- Facade: provides a unified, simplified interface to a complex system.
- FlyWeight: when huge number of similar objects and you want to save memory by sharing common state instead of duplicating it.
- Proxy:  Controls access to the real object (e.g., lazy loading, security, remote access).